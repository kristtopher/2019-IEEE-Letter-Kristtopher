%Os métodos de criptografia têm fundamental importância na privacidade e confidencialidade dos dados. Os algoritmos apresentados nesta seção pertencem à classe da criptografia de chave simétrica, uma vez que podem ser até 1000 vezes mais rápidos que abordagens assimétricas~\cite{mandal2012evaluation}. Para estes, uma mesma chave é conhecida à priori entre as partes comunicantes. O tamanho da chave implica diretamente na eficiência da proteção dos dados~\cite{jorstad1997cryptographic}, quanto maior a chave, mais seguro é considerado o canal de comunicação. Os algoritmos simétricos são de dois tipos principais: cifras de bloco e cifras de fluxo. Os algoritmos XTEA, XXTEA, RC2 e SKIPJACK são de cifras de bloco e operam em dados agrupados. Já o RC4 pertence ao grupo de cifra de fluxo, operando sobre um bit por vez. É de conhecimento geral que os algoritmos de criptografia consomem uma quantidade significativa de recursos de hardware, tais como tempo de CPU, memória e bateria~\cite{mandal2012evaluation}. A escolha de tais métodos criptográficos foi baseada nas características de projeto destes, os quais lidam com os limiares entre segurança, custo e desempenho. Deste modo, estes métodos criptográficos são conhecidos pelo termo genérico ``criptografia leve''.

%Cryptography algorithms have a fundamental importance in data privacy and confidentiality. Algorithms presented in this section belongs to 
Symmetric key cryptography %class, once that 
can be up to 1000 times faster than asymmetric cryptography~\cite{mandal2012evaluation}, and this plays a relevant point for wearable networks, in which devices and communication have constrained resources, and applications demand for low response time. For symmetric key cryptography, parties share a common key. % is the same key is known a priori between the communicating parties.
Then, the security level in the communication channel is proportional to the key size and depends on how secure is the cryptosystem when the attacker has full familiarity with its operation (Shannon's maxim and Kerchoff’s principle). % of the shared key.  %implies directly on efficiency of data protection~\cite{jorstad1997cryptographic}, how bigger the key, more safe is communication channel. 
%Symmetric algorithms are of two main types: block ciphers and stream ciphers. 

The XTEA, XXTEA, SKIPJACK and RC2 algorithms operate on data blocks; whereas RC4 operates on data streams, handling one bit at a time. %It is general knowledge that the encryption algorithms consume a significant amount of hardware resources such as CPU time, memory and battery~\cite{mandal2012evaluation}.
The choice of these encryption algorithms has considered their capability of %, as the design to %once they have been designed to 
handling thresholds related to security, cost and performance, being well-known as ``light'' cryptography algorithms. In addition to these five lightweight algorithms briefly described in the next paragraphs, we also have investigated others, e.g., KSEED, TWOFISH and CAST5. However, they have showed to be impractical for the current wearable device architecture because of the excessive memory use by data structures as matrices.

%such cryptographic methods was based on the project characteristics of these, which deal with the thresholds between security, cost and performance. Thus, these cryptographic methods are known by the generic term ``light cryptography''.

%O método \textit{eXtension to TEA} (XTEA)~\cite{needham1997tea} busca corrigir duas fragilidades da implementação base (TEA)~\cite{wheeler1994tea}, apontadas em criptoanálise. Sendo elas, o uso incompleto da chave criptográfica e operações em tamanho de bloco fixo. O XTEA procura ainda manter as principais características do seu predecessor. Entre tais características, a implementação simples, com poucas linhas de códigos e operações básicas. Esta técnica de cifra leve possui 64 rodadas, chave secreta de 128 bits e tamanho de bloco de 64 bits. Cada rodada é composta por módulos de adição, deslocamento e XOR, como estrutura Feistel. As fragilidades apontadas foram contornadas pelo uso efetivo dos 128 bits da chave ao invés dos 126 e operações em blocos de tamanhos arbitrários, perantes os 64 bits originais. A criptoanálise aponta que é possível recuperar a chave do TEA (seu predecessor) usando $2^{63.6}$ textos simples e $2^{125.05}$ textos cifrados. Já para o XTEA, a recuperação da chave necessita de pelo menos $2^{63.6}$ textos simples e $2^{126.15}$ textos cifrados~\cite{moon2002impossible}, utilizando ataques diferenciais.

%The method eXtension to TEA (XTEA)~\cite{needham1997tea} seeks to correct two frailties of the base implementation (TEA)~\cite{wheeler1994tea}, pointed out in cryptoanalysis. Being them, the incomplete use of the cryptographic key and operations in fixed block size. XTEA also seeks to maintain the main characteristics of their predecessor. Among such characteristics, simple implementation, with few lines of code and basic operations. 
The eXtension to TEA (XTEA) encryption algorithm is simple and relies on basic operations. It follows 
%This light cipher technique has 
64 rounds, employs a 128-bit key and handles blocks of 64-bits. Each round comprises of simple operations as addition, shifting and XOR. %, such as Feistel structure. 
%This algorithm employs a secret key of 128 bits, differently from its predecessor that uses only 126 bits on operations over blocks from arbitrary sizes \abv{talvez o only pega pesado. são só 2 bits a mais}. 
%
%
%The frailties pointed out were circumvented by the effective use of the 128 bits of the key instead of 126 and operations in blocks of arbitrary sizes, before the original 64 bits. 
Cryptanalysis points out that %it is possible to retrieve the TEA key (their predecessor) using $2^{63.6}$ simple texts and $2^{125.05}$ ciphertext. 
for recovering a key on XTEA it would require at least $2^{63.6}$ simple texts and $2^{126.15}$ ciphertext%~\cite{moon2002impossible}
, using differential attacks. XTEA is vulnerable to attacks in the decryption process because the algorithm uses sequential subsets of the 128 bits from the key (this phenomenon is known as slow diffusion rate). %  employs the 128 bits of the shared key. {\color{blue}the slow diffusion rate [precisamos explicar melhor.]}. \abv{acho que difusion rate não estava definido antes. e você usa ele como motivador para ser simples de atacar}
%\abv{comentario 2 = no inicio do paragrafo, voce deu ideia que o xtea seria  mais seguro porque usar mais bits... e no fim, temos conclusao oposta. entao, eu acho que a grande diferenca entre tea e xtea nao é na chave. qual será?}

%O método \textit{Corrected Block TEA} (referenciado como XXTEA)~\cite{wheeler1998correction} mantém as principais características da família, tais como implementação simples, poucas linhas de códigos e operações básicas. Esta versão da implementação tem o número de rodadas variável de acordo com o tamanho do bloco a ser cifrado. Deste modo, para cifrar 8 bytes são realizadas 12 rodadas. Assim corrigindo um ponto explorado para recuperação da chave, a taxa de difusão lenta do processo de decriptografia. Com isto, sua função \textit{round} é mais robusta, utilizando vizinhos imediatos para processar cada palavra do bloco~\cite{mishra2014feasibility}. Uma abordagem mais recente de criptoanálise~\cite{cryptoeprint:2010:254} estima que seja possível recuperar a chave a partir da consulta a aproximadamente $2^{59}$ textos simples. Os algoritmos da família TEA são considerados uma excelente solução para implementação em hardwares devido a sua simplicidade e segurança, a qual pode ser comparada ao algoritmo DES (Data Encryption Standard)~\cite{shoeb2013crypt}.

The Corrected Block TEA algorithm (XXTEA)~\cite{wheeler1998correction} keeps the simplicity of  XTEA, relying on basic and simple operations. 
%key family features, such as simple implementation, few lines of code and basic operations. 
XXTEA follows a %This version of the implementation has 
variable number of rounds depending on the block size to be encrypted. %, e.g., to encrypt 8 bytes, XXTEA performs 12 rounds.
To address the slow diffusion rate of XTEA, % the vulnerability on key recovery from XTEA, resulted from the slow diffusion rate \abv{se a gente definir antes, e ficar claro que o diffusion rate é a diferenca entre tea e xtea, podemos retirar essa oração},  
%Thus, correcting a point exploited for key recovery, 
%{\color{red}the slow diffusion rate of the decryption process. [não entendi e parece importante} {{\color{green}O uso efetivo de todos os bytes da chave é mais lento no Xtea, o que infere maior facilidade em ataques  durante a descripitografia]}. 
each round of XXTEA follows a robust function, relying on the immediate left neighbor block % {\color{red}immediate neighbors} {{\color{green}[Byte vizinho à esquerda]} 
to process each data block. \abv{o vizinho a esquerda é o bloco predecessor? como a gente nao desenhou o encadeamento de blocos, talvez a gente tenha que ser mais alto nivel}
%Its round function is more robust, using immediate neighbors to process each block word~\cite{mishra2014feasibility}. 
%A more recent approach to 
Cryptoanalysis estimates a number of $2^{59}$ simple texts  
to retrieve the secret key. % from the query at $2^{59}$ simple texts. 
%TEA family algorithms are considered an excellent solution for hardware implementation due to its simplicity and security, being compared to DES (Data Encryption Standard algorithm)~\cite{shoeb2013crypt}.

%O algoritmo Skipjack é uma cifra de bloco com 32 rodadas o qual aplica duas regras distintas, A e B. Estas regras são aplicadas intercaladas (A,B,A,B) por 8 rodadas cada. Estas regras são compostas por deslocamentos e permutações de Feistel utilizando 4 dos 8 bytes da chave simétrica por permutação. Duas abordagens adotadas para criptoanálise apontaram a complexidade de tempo de ataque na casa de $2^{48}$, utilizando $2^{34}$ textos cifrados e uma matriz de $2^{16}$ bits~\cite{biham1999cryptanalysis}.

The SKIPJACK algorithm is a 32-round block cipher which applies two distinct rules labeled as A and B. These rules are applied interleaved (A,B,A,B) for 8 rounds each. They are composed of shifts and Feistel's permutations, which use 4 of 8 bytes from the secret key per permutation. %Two approaches adopted for 
Cryptanalyses point a complexity for attacks of about $2^{48}$, using $2^{34}$ {\color{red}simple texts [no texto em português está cipher texts \rever{Reli o artigo ontem inclusive mudou-se a ordem de complexidade para textos simples, estou procurando mais dados para RC2 e RC4 para mesma notação}]} and {\color{red}$2^{16}$ bit array [Não consigo entender esta parte.\rever{este dado é refente a consumo de memoria para realizar o ataque, como o ataque nem sempre é por outro dispositivo limitado talves esta informação seja irrelevante}]}~\cite{biham1999cryptanalysis}.

%De modo análogo aos demais, o algoritmo RC2~\cite{rivest1998description} trabalha com cifra em bloco de 64 bits. Sua chave secreta proporciona flexibilidade em relação ao tamanho. O RC2 surgiu como uma proposta de substituição ao DES~\cite{smid1988data}, este ainda possui implementação mais simples e executa duas vezes mais rápido que seu predecessor. Sua implementação é composta de duas etapas distintas, expansão de chaves e criptografia. A expansão de chaves resulta em uma chave de 128 bytes a partir da chave indicada de qualquer tamanho no intervalo de 1 a 128 bytes. A criptografia consiste em 2 fases: \textit{MIXING} e \textit{MASHING}. Para realizar as permutações, faz-se necessário o uso de uma tabela de substituição. Estima-se que seja possível recuperar a chave analisando cerca de $2^{34}$ textos simples~\cite{knudsen1998design}.

%Similar to the others, 
RC2 works on 64-bit block ciphers and allows a variable key size~\cite{rivest1998description}. %  The secret key provides flexibility relating to size \abv{talvez - The method allows flexible size secret keys}. 
%RC2 came up as a replacement proposal for DES~\cite{smid1988data}, having simpler code and runs twice as fast as its predecessor. 
It follows two distinct steps: key expansion and encryption. Key expansion extends any key size, in the range of 1 to 128 bytes, to a 128-{\color{blue}byte [byte mesmo?]} key. Encryption performs MIXING and MASHING. {\color{blue}For permutations, RC2 employs %is necessary to use 
a substitution table. [permutation é o mixing? E como funciona o Mashing?]} Estimate to retrieve a secret key is proportional to the effort for analyzing about $2^{34}$ simple texts~\cite{knudsen1998design}.
%By estimation, there is a possibility to retrieve the key by analyzing about $2^{34}$ simple texts~\cite{knudsen1998design}.

%O RC4 é um algoritmo com características distintas dos demais, uma vez que a mesma função pode ser aplicada para cifrar e decifrar o fluxo de dados conforme a necessidade da aplicação. Ele é composto de duas partes, a primeira delas, apresenta um algoritmo de escalonamento de chaves (KSA) que transforma uma chave aleatória em uma permutação inicial. E a outra, consiste na geração de saída PRGA (\textit{Pseudo-Random Generation Algorithm}) que usa tal permutação para gerar uma sequência de saída pseudo-aleatória. As transformações aplicadas pelo algoritmo são lineares e simples, utilizando permutações e somas de valores inteiros, tornando-o simples e rápido~\cite{fluhrer2001weaknesses}. Analisando a segurança do RC4 em um cenário onde o protocolo permite manipulação do valor inicial da chave, a complexidade de tempo para a recuperação da chave foi de $2^{13}$ operações do algoritmo de ataque proposto~\cite{orumiehchiha2013cryptanalysis}.

RC4 differs from the previous algorithms for following the stream cipher method.  
%The RC4 is an algorithm with features different from the previous algorithms. 
RC4 employs the same function %can be applied 
to encrypt and decipher the data flow. % according to the application’s objectives. 
RC4 comprises of %Composed of two parts: the first one presents 
a Key Scheduling Algorithm (KSA) and a Pseudo-Random Generation Algorithm (PRGA). {\color{blue}KSA transforms a random key in an initial permutation [o que seria essa permutação inicial?]}, whereas PRGA %(Pseudo-Random Generation Algorithm) output, which uses such 
uses this permutation to generate a pseudo-random output sequence. Transformations applied by the algorithm are linear and simple, using permutations and sums of integer values, making it simple and fast. %~\cite{fluhrer2001weaknesses}.
Analyzing RC4 security in a scenario where the protocol allows manipulation of the initial value of the key, the complexity for key recovery is of $2^{13}$ operations% of the proposed attack algorithm
~\cite{orumiehchiha2013cryptanalysis}.

%Outros métodos de criptografia de chave simétrica foram considerados inicialmente para esta análise, tais como, KSEED, TWOFISH e CAST5. Entretanto, suas implementações e aplicação para a atual arquitetura dos sensores vestíveis revelaram-se inviáveis, uma vez que consomem demasiadamente os recursos de memória.

%{\color{blue}Other symmetric key cryptography methods were initially considered for this study, such as, KSEED, TWOFISH and CAST5. However, its implementations and application for the current wearable sensor architecture proved to be impractical, since they consume much memory resources. [Precisamos decidir se vamos citar isto. Se sim, teremos de explicar os algoritmos e apresentar evidências dos resultados mencionados.]}