\documentclass[journal]{IEEEtran}
\usepackage{subcaption} 
\usepackage{color}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{siunitx}
\usepackage{url}
\usepackage{comment}
\usepackage{multirow}

\usepackage{color}     
\newcommand{\abv}[1]{{\color{red}{[#1]}}}
\newcommand{\rever}[1]{{\color{blue}{[#1]}}}
\newcommand{\refazer}[1]{{\color{red}{[#1]}}}

\newcommand{\gn}[1]{{\color{red}{[#1]}}}

\usepackage{placeins}
\usepackage{float}
\usepackage[english,brazilian]{babel}
%\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{comment}
\usepackage{xcolor}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{cite}

\begin{document}
\title{Cryptography Algorithms in Wearable %Device
Communication: An Empirical Analysis}

\vspace{-2.0cm}

%\author{{\bf Kristtopher~Coelho}, {\bf Danilo~Damião}%~\IEEEmembership{Members,~IEEE,           	{\bf Alex~Borges},\\ %~\IEEEmembership{Fellow,~OSA,       {\bf Michele~Nogueira}, %~\IEEEmembership{Senior Member,~IEEE,}       {\bf Jos\'e Augusto M. Nacif},      {\bf Guevara Noubir}%,~\IEEEmembership{Life~Fellow,~IEEE}% <-this % stops a space
%\thanks{K. Coelho, D. Damião and J. Nacif is with the Science and Technology Institute, Federal University of Viçosa, Brazil} 

%\thanks{A. Borges is with the Department of Computer Science, Federal University of Juiz de Fora, Brazil.}% <-this % stops a space
%\thanks{M. Nogueira is with the Departmentof Computer Science, Federal University of Paran\'a, Brazil.}
%\thanks{G. Noubir is with the Department of Computer Science, Northeastern University, USA.
%}% <-this % stops a space
%\thanks{Manuscript received XX XX, 2018; revised August 26, 2015.}
%\vspace{-1.2cm}}


\markboth{IEEE COMMUNICATIONS LETTERS, VOL. XX, NO. XX, MONTH Year}%
{Coelho \MakeLowercase{\textit{et al.}}: Cryptographic Algorithms in Wearable Devices}


% make the title area
\maketitle
\selectlanguage{english}

\begin{abstract}
%\input{Abstract.tex}
In this letter, we assess the impact of lightweight block and stream ciphers on energy consumption and hardware resources of wearable devices networks. Differently from the literature, we present an empirical and hardware-driven evaluation of the most representative encryption algorithms with regard to the requirements of wearable networks. We design and implement a cryptography library useful for wireless wearable networks. Results confirm a strong correlation between the amount of logic/arithmetic operations and energy consumption under two communication standards of the IEEE 802.15 family. 
\end{abstract}

\begin{IEEEkeywords}
Wearable devices, cryptography algorithms, block cipher, stream cipher, and energy consumption. 
\vspace{-0.3cm}
\end{IEEEkeywords}


\IEEEpeerreviewmaketitle

\section{Introduction}
%\input{01introduction.tex}

Market forecasts that worldwide shipments of wearable computing devices will reach 225 million in 2019, an increase of 25.8 percent from 2018, having as major drivers
fitness and healthcare gadgets~\cite{Li:2018}. Wearable computing devices have rapidly become popular due to advancements in micro- and nano-electronics, and wireless communications. Wireless communication is essential for these advancements, once it allows the connection between devices in and around the human body, including low-rate devices like pedometers and high-rate devices like augmented-reality glasses. This communication relies on different standards such as those from the IEEE 802.15 family or the next generation mmWave 5G cellular. 

As the popularity and user-reliance on wearable devices increase, there has been an emergence of new and varied attack vectors targeting privacy intrusions, that so far cannot be addressed by classical techniques developed for Internet applications. Our goal in this letter is to empirically evaluate the existing most representative lightweight cryptography algorithms with regard to the requirements of wearable networks, such as high security and low computational resources. Most existing studies have investigated these requirements either from a software perspective~\cite{eisenbarth2012compact,kerckhof2012towards,eisenbarth2007survey} or by simulations and analytic models~\cite{cazorla2013survey,el2017equalized}. To the best of our knowledge, ours is the first to follow a hardware-driven and empirical evaluation, highlighting the impacts of the hardware specificity to cryptography algorithms in wearable devices.

Our analysis targets symmetric cryptography, where the communicating wearable devices share (possibly through a pairing or authentication and key establishment protocol) the session key used to encrypt the messages. Particularly, we focus our investigations on two different classes of symmetric lightweight encryption algorithms, as XTEA, XXTEA, SKIPJACK, RC2 and AES (block ciphers)~\cite{Moh:2015}, RC4 (stream cipher). For our hardware-driven evaluation approach, we have designed and implemented a cryptography library useful for wireless wearable devices\footnote{Available at: [URL removed because of the double-blind review process.]% \url{https://github.com/UFV-Alumni/lib_crypto}
}. For energy consumption measurements, we designed an instrumentation circuit and integrated it in the Shimmer platform\footnote{\url{http://www.shimmersensing.com}
}. The energy consumption evaluation has followed a methodology adapted from Bessa et al.~\cite{bessa2017jetsonleap}, in which we assess the power dissipation from wearable devices while they are in sleeping, idle and running states. Our analyses focused on IEEE 802.15.1 (Bluetooth) and 802.15.4 (ZigBee), as communication standards. 

The obtained results confirm the strong correlation between the amount of logic/arithmetic operations required to encrypt data block or stream, and their respective energy consumption. Results indicate that SKIPJACK algorithm as the most efficient among the evaluated algorithms in terms of energy consumption. %\gn{and security GN: SKIPJACK is very controversial-- I suggest that we do not say it is secure}
The evaluated scenarios relying on ZigBee for communications exhibit lower energy consumption than those employing Bluetooth.

This letter presents the lightweight cryptography algorithms for wearable devices (Section~\ref{sec:Background}); the designed experiments and methodology (Section~\ref{sec:Methodology}); the discussion of the obtained results (Section~\ref{sec:Results}); and conclusions (Section~\ref{sec:Conclusion}).

%\vspace{-0.3cm}

\section{Lightweight Cryptography Algorithms for Wearable Networks}
\label{sec:Background}
%\input{Algorithms.tex}

A cryptosystem consists of a plaintext space $\mathcal{P}$, a ciphertext space $\mathcal{C}$ and a key space $\mathcal{K}$, an encryption algorithm $Enc: \mathcal{K}$ x $\mathcal{P} \rightarrow \mathcal{C}$, and a decryption algorithm $Dec: \mathcal{K}$ x $\mathcal{C} \rightarrow \mathcal{P}$. For each $k \in \mathcal{K}$ and $p \in \mathcal{P}$, it is $Dec(Enc(p)_k)_k = p$. In a communication model, as introduced by Shannon~\cite{shannon}, a cryptosystem plays an important role providing security to the information from an attacker, {\em i.e.}, a malicious third entity. In the communication model, there is a sender and a receiver with a public communication channel. The sender aims at sending the plaintext (information) in a confidential way to the receiver. Confidentiality can be achieved with a cryptosystem and an additional secure channel of low bandwidth.  

Symmetric key cryptography assumes a secure channel used by the communicating parties to establish a secret session key $k$, not accessible to the adversary. Given $p$, $k$, and the cryptosystem, the sender can construct the ciphertext $c$ and send it to the receiver over the public communication channel. The receiver can then reconstruct the plaintext $p$, given $c$, $k$, and the cryptosystem. Symmetric key cryptography is relevant for wearable networks, in which devices and communication have constrained resources, and applications demand for low response time. In this context, the attacker's main goal lies in recovering $p$ or $k$ and, according to Kerckhoff’s principle, an attacker knows the specification of the cryptosystem and has access to the ciphertext $c$. 

While there has been significant progress over the last decades in modeling and formally reasoning about the security cryptographic primitives~\cite{KatzL2014}, this work focuses on the energy consumption analysis of established block and stream ciphers. %, {\em i.e.}, two different classes of symmetric algorithms. 
A block cipher is a cryptosystem with $\mathcal{P} = \mathcal{C} =  \mathbb{F}^n$ for a block size $n$, where  $\mathbb{F}$ denotes the Galois field of two elements and $\mathbb{F}^n$ is the vector space of dimension $n$ over $\mathbb{F}$. For each key $k$, the encryption function $Enc(p)_k$ is a permutation. In the most general case, the $\mathcal{K}$ corresponds to the set of permutations of size $2^n!$, where a single $k$ lies in a table of size $2^n$. %It is reasonable to 
The use of a subset of the permutations is reasonable, which can be generated with a small key. To encrypt messages longer than the block size, a mode of operation is employed, such as Cipher Block Chaining or Counter Mode, and to provide integrity protection modes, such as Galois Counter Mode~\cite{KatzL2014}. 

A stream cipher encrypts binary digits of a plaintext one at a time. %In a nutshell, i
It folows an internal state $x \in \mathcal{X}$, an update function $L: \mathcal{X} \rightarrow \mathcal{X}$ and an output function $f: \mathcal{X} \rightarrow \mathcal{Z}$, where $\mathcal{Z}$ is called the keystream alphabet. An output $z \in \mathcal{Z}$ at time $t$ is produced according to $zt = f(xt)$, where $xt = Lt(x)$ and $x$ is the initial state. The initial state $x$ results from an initialization function, a secret key $k$, and an initialization vector. The stream of outputs $z_0, z_1, \ldots$ is called the keystream. Each output symbol is combined with the corresponding plaintext symbol to produce a ciphertext symbol.

XTEA, XXTEA, SKIPJACK, RC2 and AES are block ciphers; whereas RC4 is a stream cipher. These encryption algorithms have the capability of handling thresholds related to security, cost and performance, being well-known as ``light'' algorithms. In addition to these six lightweight algorithms, briefly described in the next paragraphs, we have initially considered others, e.g., KSEED, TWOFISH and CAST5. However, they have showed to be impractical for the current wearable device architecture due to the excessive memory use.

The eXtension to TEA (XTEA) and the Corrected Block TEA (XXTEA) encryption algorithms employ a 128-bit key and blocks of 64-bits. XTEA operates in 64 rounds and XXTEA has a variable number of rounds. In both, permutations follow simple operations, {\em e.g.}, addition, shifting and XOR. For key recovery, cryptanalysis estimates at least $2^{63.6}$ plaintexts and $2^{126.15}$ ciphertexts for XTEA, and $2^{59}$ plaintexts for XXTEA \cite{moon2002impossible}%\gn{is this against the reduced 36 rounds version? we need a citation}
. XTEA decryption process is considered prone to attacks due the use of sequential subsets of the 128 bits from $k$. % (this phenomenon is known as slow diffusion rate). 
Hence, each round of XXTEA relies on a robust function leveraging the immediate previously addressed block. 

The SKIPJACK algorithm is a 32-round cipher which applies two distinct rules labeled as A and B. These rules are applied interleaved as A, B, A, B per 8 rounds. Permutations comprise of shifts and Feistel's, which use 32 of the 64 bits from the secret key per permutation. Despite the controversy around SKIPJACK design, cryptanalysis point out a resistance for attacks of $2^{48}$, using at least $2^{34}$ plaintexts~\cite{biham1999cryptanalysis}%~\cite{biham1999cryptanalysis}%~\cite{Moh:2015} \gn{GN: need to double check}
. As SKIPJACK, RC2 works on 64-bit blocks and allows a variable key size~\cite{knudsen1998design}. It follows two distinct steps: key expansion and encryption. Key expansion can extend any key size, in the range of 1 to 128 bytes, up to a 128-byte key. Encryption performs permutations based on a substitution table. Estimates to retrieve a secret key are proportional to the effort for analyzing about $2^{34}$ plaintexts~\cite{biham1999cryptanalysis}.%~\cite{Moh:2015}.

%\rever{O algoritmo Advanced Encryption Standard (AES) tornou-se a principal escolha para vários serviços de segurança em inúmeras aplicações, como redes de sensores sem fio por exemplo, isto devido a sua forte defesa contra ataques conhecidos. A abordagem de \cite{nasser2016aes} apresenta uma versão otimizada para dispositivos que não dispõem de alta capacidade de computacional e recursos de memória, proporcionando ainda um menor consumo energético. O que credencia tal versão à avaliação. Entretanto esta proposta oferece uma segurança limitada, juntamente a um processamento mais lento. Além disso,  não apresenta dado referentes à criptoanálise.}

The Advanced Encryption Standard (AES) algorithm has become the primary choice for various security services % in numerous applications %, such as wireless sensor networks, 
due to its strong defense against known attacks. The best known attacks against AES are slightly faster than brute-force and require $2^{126.2}$ operations to recover an AES-128 key. In~\cite{nasser2016aes}, the authors presented an optimized version of AES for devices with low computational capacity and memory resources, while still providing low power consumption. This is the evaluated version in this letter. %Unfortunately, this version of AES offers limited security along with slower processing\gn{what does this mean?}. 

RC4 is a stream cipher and it comprises of a Key Scheduling Algorithm (KSA) and a Pseudo-Random Generation Algorithm (PRGA). KSA transforms a random key in an initial permutation, whereas PRGA uses this initial permutation to generate a pseudo-random output sequence. Cryptographic transformations applied by the algorithm are linear and simple, using permutations and sums of integer values. However, secure use of RC4 is non-trivial as experienced with Wi-Fi WEP. For instance, in a scenario where the protocol allows manipulation of the initial value of the key, the complexity for key recovery is of $2^{13}$ operations~\cite{orumiehchiha2013cryptanalysis}.
\vspace{-0.2cm}
\section{Experiments and Methodology}
%\input{Methodology.tex}
\label{sec:Methodology}

%The experiments in this letter rely on wearable devices from the Shimmer platform, model 2R. These devices sense vital signs and movements from users by accelerometers, magnetometers, and gyroscope, and transmit them to a coordinator device (e.g., a smartphone) through wireless communication, such as Bluetooth or Zigbee. These devices run the Real Time Operating System (RTOS) together to TinyOS. NesC is the programming language for software development, including the operating system.      
The experiments in this letter rely on wearable devices from the Shimmer platform, model 2R. These devices are equipped with a MSP430 F1611 microcontroller, 16-bit RISC architecture. Each device contains 48KB + 256B flash memory and 10KB RAM. These devices sense vital signs and movements from users by accelerometers, magnetometers, and gyroscope, and transmit them to a coordinator device ({\em e.g.}, a smartphone) through wireless communication, such as Bluetooth or Zigbee. The Shimmer platform employs the Roving Networks RN-42, a low-cost and low-power Bluetooth module. The Zigbee module follows the CC2420 radio transceiver, designed for size-constrained, low-power and low-current applications. These devices run the Real Time Operating System (RTOS) together to TinyOS. %NesC is the programming language for software development. % including the operating system.

Energy consumption is measured in three different states ({\em i.e.}, idle, sleep and run). At a glance, we set up the wearable device to the desired state and continuously monitor it. The wearable is automatically placed in a low-power mode when the task queue is empty (\textit{idle}: state 1). We can manually adjust the microprocessor for sleep mode (\textit{sleep}: state 2). In this sense, we are able to measure the wearable device power consumption. Finally, to analyze the wearable on run state, we setup the device to continuously perform a cryptography task --- on 64-bits data blocks --- using one of the aforementioned cryptography algorithms, followed by the encrypted data transmission using ZigBee ({\em run:} state 3) or Bluetooth ({\em run:} state 4). Finally, unless we tell otherwise, at each state we perform 2000 samples and present mean confidence interval of 95\%.

\begin{figure}[tbh]
 %\vspace{-0.3cm}
  \centering
  \includegraphics[scale=0.19]{Figures/estados.png}
  \caption{Wearable device states}
  \label{fig:states}
  \vspace{-0.5cm}
\end{figure}

We have designed and assembled a circuit for energy consumption measurement adapted from~\cite{bessa2017jetsonleap}. The circuit comprises of a low cost data acquisition board (DAQ - ADALM1000) connected to a wearable, a 0.10~\si{\ohm} resistor, and a computer (Figure~\ref{fig:circuit}). We use Active Learning Interface for Circuits and Electronics (ALICE) software to acquire voltage measurements from both terminals of the resistor which are connected to channels CH\_A and CH\_B of the DAQ. The voltage can be easily transformed to current following the law of Ohm, $V = R$ x $I$, since the resistance value is known. 
To make comparisons, we calculate the power consumption by multiplying the current to the voltage. Then, power consumption follows: 
$P = ((\mbox{CH\_A} - \mbox{CH\_B}) / 0.10) * V $ mW.

\begin{figure}[!htb]
 \vspace{-0.1cm}
  \centering
  \includegraphics[scale=0.19]{Figures/circuit.png}
  \caption{Energy consumption measurement}
  \label{fig:circuit}
  \vspace{-0.3cm}
\end{figure}

DAQ delivers a maximum sampling rate of 100 ksps (kilosamples per second).  Therefore, we calculate energy consumption, mean, and the total consumption time for the algorithms in each analyzed state of wearable devices. Also, the computational complexity of the algorithms is of great relevance because energy consumption bottlenecks occur during data processing and transmission. Hence, we also consider the size of machine code, when it represents a large share of the hardware resource consumption.

In addition to energy consumption, we analyze the main operations in each cryptographic algorithm. We enumerate all the logical and arithmetic operations, when we want to confirm if the number of operations can be directly correlated with the final performance and energy consumption of each algorithm implementation. Also, since wearable devices are severely constrained in computational resources, we analyze the amount of memory the implementation of each algorithm requires. We derive this information using the NesC compiler.

%\vspace{-0.4cm}

\section{Results}
\label{sec:Results}
%\input{Consumption_Evaluation.tex}

Power consumption is one of the critical factors in the design and development of wearable networks for both high-end and low-end embedded devices. Therefore, a comprehensive energy efficiency analysis, considering all possible factors is of great relevance. A Power State Machine (PSM) represents the possible states of the device, and a transition between two states means energy cost and delay. %consolidating state change. 
Thus, low power  states have a  longer delay  between  transitions for {\em run} states. The transition  time is presented in~\cite{goraczko2008energy}. The time for other transitions is considered %as , where it stil infers that the times of the other transitions are 
insignificant and, for the matter of simplicity, it is not represented in the PSM.


Figure~\ref{fig:PSM_geral} represents the PSM of the wearable device we analyze in this work. Regardless the transmission mode on {\em run} state ({\em i.e.} ZigBee or Bluetooth), the {\em sleep} and {\em idle} states of the device present a mean energy consumption of 226.95\,mW and 236.21\,mW, respectively. The difference is of only 4.08\%, because wearable devices are automatically placed in low-power mode when they are not performing tasks. The {\em sleep} state presents a slightly higher transition time than the {\em run} state, when compared to the transition between the {\em idle} and {\em run} states. Thus, the fact that the {\em idle} state automatically operates at low power makes it attractive for relieving the developer from managing different sleep levels and their interruptions. 

\begin{figure}[tbh]
% \vspace{-0.3cm}
  \centering
  \includegraphics[scale=0.3]{Figures/C_PSM_geral.png}
  \caption{Wearable device power state machine (PSM)}
  \label{fig:PSM_geral}
  \vspace{-0.2cm}
\end{figure}

\begin{figure*}[!t]
  %\vspace{-0.5cm}
\centering
  \begin{subfigure}[b]{0.35\textwidth}
    \includegraphics[width=\textwidth]{Figures/cdf_blue_aes.png}
    \caption{Power consumption per state using Bluetooth}
    \label{fig:cdf_blue}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.35\textwidth}
    \includegraphics[width=\textwidth]{Figures/cdf_zig_aes.png}
    \caption{Power consumption per state using ZigBee}
    \label{fig:cdf_zig}
  \end{subfigure}
  \vspace{-0.2cm}
  \caption{Energy consumption on the {\em run} state}
  \vspace{-0.45cm}
\end{figure*}

%Moreover, t
The {\em run} state, which encompasses data processing and transmission, asymptotically dominate energy consumption. For example, the {\em run} state using Bluetooth spends up to 84\% more energy than the {\em idle} state, , in the worst case. Clearly, for both communication standards, SKIPJACK presents the lowest energy consumption among the evaluated algorithms. SKIPJACK, associated with Bluetooth or Zigbee, spends 30.12\% to 17.56\% less energy, respectively, than AES (which demands the highest amount of energy). Finally, ZigBee reduces the average energy consumption by 17.37\% compared to Bluetooth.

Figures~\ref{fig:cdf_blue} and~\ref{fig:cdf_zig} detail the  energy consumption per state and  present the Cumulative Distribution Function (CDF) for each evaluated scenario. Figure~\ref{fig:cdf_blue} shows results when using Bluetooth, whereas Figure~\ref{fig:cdf_zig} presents results for the use of ZigBee. Results for energy consumption following each cryptographic algorithm showing the average energy consumption per state are summarized in Figure~\ref{fig:PSM_geral}. %We note that 
SKIPJACK is the most efficient among all evaluated algorithms, and AES the least. 

The computational cost of logical and arithmetic operations has direct effect on processing time and wearable device energy consumption. The operations considered are {\em shift left, shift right, and, or, not, xor, sum, subtraction}, and {\em multiplication}. Table~\ref{tab:comp} shows the number of operations for each evaluated algorithm. The count is relative to the encryption function, once the wearable device performs this function, but not decryption. Thus, energy consumption has a direct correlation with the number of operations. We again have a positive observation for SKIPJACK, that presented fewer operations to encrypt a 64-bit data block.

\begin{table}[h!]
\scriptsize
\centering
\begin{tabular}{l|c|c|c} 
\hline
ALGORITHM  & \begin{tabular}[c]{@{}c@{}}KEY SIZES\\(BITS) \end{tabular} & \begin{tabular}[c]{@{}c@{}}NUMBER OF\\OPERATIONS \end{tabular}  & \begin{tabular}[c]{@{}c@{}}MEMORY\\CONSUMPTION\\(BYTES) \end{tabular} \\ 
\hline
SKIPJACK & 80  & 496  & 7442 \\
XTEA     & 128 & 576  & 7384 \\
RC2      & 128 & 804  & 7512 \\
XXTEA    & 128 & 1490 & 7668 \\
RC4      & 128 & 1992 & 7598 \\
AES      & 128 & 2704 & 26046\\
\hline
\end{tabular}
\caption{Computational cost of logical/arithmetic operations}
\label{tab:comp}
\vspace{-0.5cm}
\end{table}

Table~\ref{tab:comp} also shows information about memory use (including ROM and RAM usage) for the implementation of each cryptography algorithms using NesC. %. When compiling the implementations of the cryptography algorithms using NesC, some information is reported, . 
To collect such information, we have compiled the implementation of each algorithm independently of any other function. Hence, we can assert that the presented data refers exactly to each algorithm. We  note  a  low  difference  in  total  resource allocation (about 3.85\%) between XTEA and SKIPJACK.

Table~\ref{tab:instr} compares the number of Assembly instructions for the implementation of each evaluated algorithm. We have counted the number of Assembly instructions with the help of the Godbolt online compiler and a manual process known as Table Test. The Godbolt compiler converts programs from several languages into Assembly code. %It allows us to have an Assembly code that really reflects the instructions compiled for Shimmer wearable devices. 
For the experiment we use the MSP430 gcc compiler version 5.3.0 without optimization directives and then we convert the NesC code to Assembly code. Next, using the Table Test we have counted the final number of Assembly instructions. Table~\ref{tab:instr} also shows the asymptotic complexity of each algorithm.

\begin{table}[!h]
\scriptsize
\centering
\setlength\tabcolsep{5pt} % default value: 6pt
\begin{tabular}{l|c|c|c|c|c} 
\hline
ALGORITHM  & \begin{tabular}[c]{@{}c@{}}\#INSTR.\\PER\\ROUND \end{tabular} & \begin{tabular}[c]{@{}c@{}}\#ROUNDS \end{tabular}  & \begin{tabular}[c]{@{}c@{}}MAIN\\LOOP \end{tabular} &
\begin{tabular}[c]{@{}c@{}}TOTAL\\\#INSTR. \end{tabular} &
\begin{tabular}[c]{@{}c@{}}COMPLEXITY \end{tabular} \\ 
\hline
SKIPJACK & 20-21  & 32 & 665   & 760   & $O(1)$\\
XTEA     & 37       & 32 & 1184  & 1206  & $O(1)$\\
RC2      & 95-118 & 16 & 1550  & 1645  & $O(1)$\\
XXTEA    & 479      & 12 & 5748  & 5776  & $O(n)$\\
RC4      & 50       & 8  & 400   & 10677 & $O(n)$\\
AES      & 2404     & 9  & 21636 & 24117 & $O(1)$\\
\hline
\end{tabular}
\caption{Number of Assembly instructions }
\label{tab:instr}
\vspace{-0.3cm}
\end{table}

%\rever{
%Related to cryptanalysis and
Complementing the information in Section~\ref{sec:Background}, we analyze the tradeoff between energy consumption and the level of security for each algorithm. SKIPJACK and AES are the two extremes, {\em i.e.}, SKIPJACK is the most energy efficient; whereas AES has the highest energy consumption. In terms of security, AES is believed to be the most secure. We however note that we do not consider side-channel attacks.
%to satisfy the limitations of the hardware we can not assume anything, since its cryptanalysis was not presented.
%}

%Related to cryptanalysis, complementing the information presented in Section~\ref{sec:Background}, we analyze the thread-off between energy consumption and the level of security for each algorithm. SKIPJACK and RC4 are the two extremes, i.e., SKIPJACK is the best and RC4 is the worst in terms of energy consumption versus security level. SKIPJACK shows again advantages, because it has time complexity for key recovery of $2^{48}$ versus $2^{13}$ of RC4. Compared  to  XTEA  and  XXTEA, SKIPJACK shows low efficiency in relation to key recovery through plaintexts, being similar to RC2.

\vspace{-0.3cm}

\section{Conclusion}
\label{sec:Conclusion}
%\input{Conclusion.tex}

In this letter, we investigate several key block and stream ciphers, resource usage and power consumption for end-to-end wearable devices secure communications. Differently from related work, we perform a hardware-driven power consumption measurements evaluation under two communication standards from the IEEE 802.15 family. The SKIPJACK algorithm exhibits the best performance for wearable devices with constrained resources. It has the lowest average energy consumption among the  evaluated algorithms and the second least memory resource usage. Moreover, this algorithm offers a considerable key recovery complexity for symmetric key cryptography algorithms. AES exhibits the highest energy consumption. %On the other hand, 
A general observation is that the overhead due encryption is negligible when compared to the offered security and low energy dissipation level for all implemented and evaluated algorithms.

\vspace{-0.5cm}

\selectlanguage{english}
\bibliographystyle{IEEEtran}
\bibliography{bibtex/bib/Letter.bib}

\end{document}